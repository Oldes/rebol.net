=All about the MONEY datatype - high-precision arithmetic for financial and scientific applications.=

==Overview==

The money datatype now uses a coded decimal representation, allowing accurate number representation up to 26 decimal digits in length. Due to its accuracy, this datatype is useful for financial, banking, commercial, transactional, and even some types of scientific applications.

==Format==

===External===

Externally, money is represented as it was on R2. Within code and data, a $ indicates that datatype is being specified:

<pre>
$1.23
-$1.23
</pre>

Unlike in R2, money remains accurate up to 26 digits:

<pre>
>> $123456789012345678901234.56 + $0.01
== $123456789012345678901234.57
</pre>

Compare this with what happens when using Rebol decimal! (64-bit IEEE754 binary floating point) values:

<pre>
>> 123456789012345678901234.56 + 0.01
== 1.2345678901234569E+23
</pre>

Many digits are lost in the original number, and the 0.01 addition is completely lost in rounding.

The difference can be seen even "sooner", as the following example shows:

<pre>
>> $0.30 - $0.20 - $0.10
== $0
</pre>

While using the Rebol decimal! datype we obtain:

<pre>
>> 0.30 - 0.20 - 0.10
== -2.77555756156289E-17
</pre>

The reason behind this is that numbers like 0.30, 0.20 or 0.10 can be exactly represented by the money! datatype, while they cannot be represented exactly by Rebol decimal! (64-bit IEEE754 binary floating point) datatype.

(This property is why the money datatype is useful for financial and transactional applications where accuracy is required.)

Additionally it is possible to use it when doing some integer arithmetic needing up to 26 decimal digits like in this example (exactly computing 2 ** 64, which cannot be done in Rebol integer format):

<pre>
>> a: $1 loop 64 [a: a * $2]
== $18446744073709551616
</pre>

The accurate result can be obtained for up to 2 ** 86, 2 ** 87 is the first power of two needing more than 26 decimal digits.

