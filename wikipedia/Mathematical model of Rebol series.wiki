==Introduction==

Rebol series like strings and blocks incorporate:

* fast index access

* methods for traversing and skipping

* built-in bounds checking

This article:

* defines a mathematical model of Rebol series
* discusses the current state of the interpreter
* proposes changes

==Mathematical model of Rebol series==

'''Definition:''' we say that a mathematical function <code>S</code> is a ''Rebol series'' if:

* <code>S('datatype)</code> is one of the series! datatypes (series! datatypes are: string!, binary!, block!, ...),

* <code>S('displacement)</code> is a 32-bit signed integer, i.e., an integer value such that <code>-2147483648 <= S('displacement) <= 2147483647</code>,

* and <code>S('payload)</code> is a payload.

'''Note:''' in the model, the series displacement is defined as a 32-bit signed integer, since in current interpreter versions, skips, offsets, etc. are implemented using 32-bit signed integers.

===Payload===

'''Definition:''' we say that mathematical function <code>D</code> is a ''payload'' if for every execution time <code>t</code>:

* the value <code>D(t,'size)</code> is a nonnegative 32-bit signed integer value, i.e., <code>0 <= D(t,'size) <= 2147483647</code>,

* and for every 32-bit signed integer <code>i</code> called the ''payload index'' holds:

** <code>D(t,i) = #[none]</code> if <code>i < 0</code>,

** <code>D(t,i)</code> is a Rebol value if <code>0 <= i < D(t,'size)</code>,

** and <code>D(t,i) = #[none]</code> if <code>D(t,'size) <= i</code>

'''Note:'''

* <code>D(t,'size) = 0</code> is allowed, in which case we say that the payload is empty.

* for the same reasons as above it only makes sense to use 32-bit signed integers for payload size, and since negative sizes do not make sense, only nonnegative numbers are allowed.

'''Convention:''' from now on, unless otherwise stated, symbol <code>t</code> will denote the execution time of the expression, i.e., the time when the expression is evaluated.

===The head of a series===

The <code>head</code> function is a function accepting a Rebol series <code>S</code> and returning its head.

We define that a series is a head of the series <code>S</code>, if it has a displacement 0 and the same datatype and payload as <code>S</code>, i.e.:

* <code>head(S)('displacement) = 0</code>
* <code>head(S)('datatype) = S('datatype)</code>
* <code>head(S)('payload) = S('payload)</code>

===Finding out whether a series is at its head===

The <code>at-head?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the given series is its own head, i.e.,

* <code>at-head?(S) = #[true]</code> if <code>S('displacement) = 0</code>,

* and <code>at-head?(S) = #[false]</code> if <code>S('displacement) <> 0</code>.

Note that the <code>at-head?</code> function is time-independent.

Comparing the <code>at-head?</code> function to the <code>head?</code> function, we find out that for Rebol 2.7.8:

* the <code>head?</code> function is time-dependent

<pre>
a: [1 2]
b: skip a 2
head? b ; == false
clear a
same? b head b ; == false
head? b ; == true
insert a [1 2]
head? b ; == false
</pre>

* If we take the <code>head</code> function as the definition of the head, the <code>head?</code> function is incorrect. To be correct, it should work like the <code>at-head?</code> function.

===Finding out whether a series is at a pre-head position===

The <code>pre-head?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the series is at a pre-head position, i.e.

* <code>pre-head?(S) = #[true]</code> if <code>S('displacement)</code> is negative,

* and <code>pre-head?(S) = #[false]</code> if <code>S('displacement)</code> is nonnegative.

Note that the <code>pre-head?</code> function is time-independent.

===The tail of a series===

The <code>tail</code> function is a function accepting a Rebol series <code>S</code> and returning its tail, i.e., a series having the same datatype and payload as the original series, and a displacement equal to the size of the payload of the original series:

* <code>tail(S)('datatype) = S('datatype)</code>,

* <code>tail(S)('payload) = S('payload)</code>,

* and <code>tail(S)('displacement) = S('payload)(t,'size)</code>.

Tests suggest that this model is implemented in the Rebol 2.7.8 interpreter as the <code>tail</code> function.

Note that as opposed to the <code>head</code> function, the <code>tail</code> function is time-dependent.

===Finding out whether a series is at its tail===

The <code>at-tail?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the series is at its tail:

* <code>at-tail?(S) = #[true]</code> if <code>S('displacement) = S('payload)(t,'size)</code>,

* and <code>at-tail?(S) = #[false]</code> if <code>S('displacement) <> S('payload)(t,'size)</code>.

Comparing the <code>at-tail?</code> function to the <code>tail?</code> function, we find out that for Rebol 2.7.8:

* If we take the <code>tail</code> function as the definition of the tail, the <code>tail?</code> function is incorrect. To be correct, it should work like the <code>at-tail?</code> function:

<pre>
a: [1 2 3]
b: skip a 2
clear a
same? b tail b ; == false
tail? b ; == true
</pre>

===Finding out whether a series is at a past-tail position===

The <code>past-tail?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the series is at a past-tail position:

* <code>past-tail?(S) = #[true]</code> if <code>S('displacement) > S('payload)(t,'size)</code>,

* and <code>past-tail?(S) = #[false]</code> if <code>S('displacement) <= S('payload)(t,'size)</code>.

===Finding out whether a series is empty===

The <code>is-empty?</code> function should take a series as an argument and yield a logic! type value determining whether the given series is empty:

* <code>is-empty?(S) = #[true]</code> if <code>max(0,S('displacement)) < S('payload)(t,'size)</code>,

* and <code>is-empty?(S) = #[false]</pre> if <code>max(0,S('displacement)) >= S('payload)(t,'size)</code>.

Comparing the <code>is-empty?</code> function and the <code>empty?</code> function in Rebol 2.7.8 we find out that

<pre>
empty? #[block! [] -1] ; == false
</pre>

, while the <code>is-empty?</code> function would yield <code>true</code>.

===Determining the length of a series===

The <code>length-of</code> function is a function accepting a Rebol series <code>S</code> and returning a nonnegative integer determining the length of the series, i.e.,

<pre>
length-of(S) = max(0,S('payload)(t,'size) - max(0,S('displacement)))
</pre>

The <code>length?</code> function in the Rebol 2.7.8 interpreter does not work like that as this test demonstrates:

<pre>
length? #[block! [] -2] ; == 3
</pre>

, while the <code>length-of</code> function yields 0 in such case.

===Index arithmetic===

====Least Absolute Remainder====

For integer <code>a</code> and nonzero integer <code>b</code> we define

<code>r = LAR(a,b)</code> (read: "<code>r</code> is the Least Absolute Remainder of <code>a</code> divided by <code>b</code>") if

* <code>a - r</code> is divisible by <code>b</code>,

* and <code>-abs(b) <= r + r < abs(b)</code>,

Where <code>abs</code> is the absolute value.

====32-bit signed arithmetic with wrapping====

For integer <code>a,b</code> we define

<code>add-wrap(a,b) = LAR(a + b,2 ** 32)</code>,

and <code>subtract-wrap(a,b) = LAR(a - b,2 ** 32)</code>.

Advantages if the two's complement representation is used:

* both functions accept any pair of 32-bit signed integers and yield a 32-bit signed integer as a result

* for every pair of 32-bit signed integers <code>a,b</code> holds that

<pre>
a = add-wrap b subtract-wrap a b
</pre>

Notes:

* The limitation to two's complement representation of signed integers is not that bad, e.g., the gcc does not offer any other representation of signed integers.

* The advantage of the two's complement representation compared to one's complement or sign/magnitude representations are that the two's complement is the only representation capable of representing all least absolute remainders of <code>2 ** 32</code>, i.e., it is the only representation for which the <code>LAR</code> function and the wrapping addition and subtraction always yield a representable 32-bit integer.

====Finding the offset between two series====

Sometimes it is useful to know the offset between two series. If the displacements of the series are signed 32-bit numbers, it is possible to calculate the offset as a signed 32-bit number too, using the formula:

<pre>
offset-of(S,T) = subtract-wrap(T('displacement),S('displacement))
</pre>

The main difference between the <code>offset-of</code> function and the standard <code>offset?</code> function is that there are series for which the <code>offset?</code> function does not work due to overflow (Rebol 2.7.8):

<pre>
>> a: #[block! [1 2] -2147483646] none
>> offset? tail a a
** Math Error: Math or number overflow
** Where: offset?
** Near: subtract index? series2 index? series1
</pre>

====Determining the payload index====

Given a series <code>S</code> and and index <code>i</code>, the task is to define a <code>payload-index</code> function such that the <code>i</code>-th position in <code>S</code> corresponds to the <code>payload-index(S,i)</code>-th position in its payload.

The function can be used to define the <code>pickz</code> function. However, this is not the only use of such a function. It would be useful for other indexing purposes as well.

In my opinion, the simplest and most useful definition is:

<pre>
payload-index(S,i) = add-wrap(S('displacement),i)
</pre>

===Picking values===

A simple <code>pickz</code> function:

<pre>
pickz(S,i) = S('payload)(t,payload-index(S,i))
</pre>

==Implementations==

===Displacement===

The mathematical model uses a displacement, although there is no direct method to examine its value. However, there are numerous indirect informations we can use:

* Rebol interpreters are implemented in C, i.e., C is the native code of the interpreter, which signals that there may indeed be a native 32-bit integer used as the displacement.

* Rebol 2.7.8 can construct pre-head series like <code>#[block! [1] -1]</code>, which signals that if there is a displacement, it must be a signed integer.

* Suppose that in Rebol 2.7.8 there indeed is a native 32-bit signed displacement which is examined by the <code>index?</code> function, usually returning it increased by 1. Since the smallest signed integer in two's complement is -2147483648, it is logical to expect -2147483647 to be the smallest index value obtainable as a result of the <code>index?</code> function. And, indeed, in Rebol 2.7.8 <code>index? #[block! [1] -2147483647] ; == -2147483647</code>, while <code>index? #[block! [1] -2147483648] ; == 2</code>, which signals that there is some kind of arithmetic overflow present in the latter case. While the overflow looks handled, the specific result does not look correct.

* The past-tail series can not only be created, but, in accordance with the mathematical model, their creation cannot be suppressed (Series have time-independent displacement and time-dependent payload, which can shrink.) This does not hold just for the mathematical model, but it also turns out to be true both in Rebol 2.7.8 and in Rebol 2.101.0:

<pre>
a: [1 2]
b: skip a 2
mold/all b ; == #[block! [1 2] 3]
clear a
mold/all b ; == #[block! [] 3]
</pre>

* , there are obvious inconsistencies, however:

** While <code>mold/all</code> handles past-tail series correctly, <code>mold</code> errors on them in Rebol 2.7.8. This leads to interpreter crashes when <code>mold</code> is used to print error causing code. In Rebol 2.101.0 this error has been corrected. Example of error: <code>error? try [mold b] ; == true</code>

** In Rebol 2.7.8 as well as in Rebol 2.101.0, the <code>index?</code> function truncates past-tail indices to tail indices, which is another inconsistent behaviour, since there always is a way how to determine the correct (untruncated) value.

** In Rebol 2.7.8 as well as in Rebol 2.101.0, the <code>load</code> function truncates past-tail indices to tail indices, which is inconsistent with the behaviour of the <code>mold</code> function. Example: <code>mold/all load "#[block! [] 3]" ; == "[]"</code>

* In Rebol 2.101.0, the <code>load</code> function always truncates negative indices in construction syntax to tail. Example: <code>mold/all #[block! [1] -1] ; == "#[block! [1] 2]"</code>

* The fact that Rebol 2.101.0 always truncates negative indices to tail suggests that Rebol 2.101.0 considers them to be greater than "normal" positive 32-bit numbers. This signals that Rebol 2.101.0 handles the values as unsigned "under the hood". This, on one hand, signals that the assumption in the mathematical model that the displacement is a signed integer is not valid for Rebol 2.101.0, but, on the other hand, it also signals that the design of Rebol 2.101.0 is, in this sense, inconsistent with the usage of signed numbers in series functions such as <code>pick</code>, which accepts pre-head indices returning <code>#[none]</code> as the corresponding element, and also, that the handling of pre-head series (Pre-head series cannot exist when the displacement is unsigned), is inconsistent with the handling of past-tail series (As opposed to pre-head series, past-tail series cannot be suppressed as mentioned above.)

====Pre-head and past-tail displacements====

As already discussed, at least past-tail positions cannot be suppressed, and it is always possible to detect whether the given series is a past-tail series or not. For consistency, (not just between pre-head and past-tail handling, but also with functions using any signed index such as <code>pick</code>) it appears to be best to acknowledge not just the existence of past-tail series, but also the existence of pre-head series. The acknowledgment does not just improve consistency, it also improves flexibility and can simplify indexing as in the following case:

Assume that a user wants to use a series of values <code>[d e]</code> indexed by numbers in the <code>[3..4]</code> range. To be able to do it using the Rebol 2.100.111 interpreter the user needs to define:

<pre>
my-series: [#[none] #[none] d e]
</pre>

Now:

<pre>
pick my-series 3 ; == d
pick my-series 4 ; == e
</pre>

In <code>rebol/version == 2.7.8</code> the following works:

<pre>
index? my-series: #[block! [d e] -1] ; == -1
pick my-series 3 ; == d
pick my-series 4 ; == e
</pre>

Comparing the two alternatives we see that in Rebol 2.7.8 using pre-head series, we did not have to insert the extraneous <code>#[none]</code> values to the block to achieve the desired effect. Thus, in addition to consistency, the approach acknowledging the existence of pre-head series turns out to be more flexible as well.

==Head series==

Tests suggest that the model of the <code>head</code> function is equivalent to the function implemented in both Rebol 2.7.8 and Rebol 2.101.0 interpreters.



'''Definition:''' ''Pre-head series'' are series having a negative <code>displacement</code>.

Problems:

* When discussed (if discussed at all), pre-head series are called "illegal series". That is inconsistent with the fact that such series can be created in Rebol 2.7.8:

<pre>
index? #[block! [a] -2] ; == -2
</pre>

* Pre-head series are treated obscurely, as "Series that must not be mentioned in the documentation".

* Simple reflectors detecting pre-head series are missing in the interpreter.

* The <code>mold</code> function is not able to handle pre-head series triggering an error (while <code>mold/all</code> works without a quirk). This is a serious problem - the <code>mold</code> function is used to print error reports and must not trigger an error when printing an error report unless we want the interpreter to crash.

* The <code>pick</code> function uses the approach characterized by many as the most useful, and allows picking at pre-head positions without triggering an error.

* Inconsistently with <code>pick</code> and <code>load</code>, the <code>back</code>, <code>skip</code> and <code>at</code> functions refuse to go to pre-head positions.

Possible amendments:

There are two different methods trying to handle the pre-head series:

* Amend the interpreter to not produce pre-head series at all - this approach has been tried in Rebol 2.100.111.

* Handle pre-head series consistently.

====Pre-head handling used in Rebol 2.100.111====

* The <code>load</code> function accepts the code <code>#[block! [a] -3]</code> as "legal" and produces a result that is incompatible with the specification instead of triggering an error.

* Due to the fact that it is impossible to suppress past-tail positions, this approach is not usable for past-tail series, meaning that this approach is and has to be inconsistent with the approach used to handle past-tail series.

* This approach is incompatible and inconsistent with the behaviour of the <code>pick</code> function. It would be possible to change the behaviour of the <code>pick</code> function, but there is a broad agreement between Rebol users that the current behaviour of the function is useful and convenient.

* some users want to use pre-head series:

'''Example:''' Let's assume that a user wants to use a series of values <code>[d e]</code> indexed by numbers in the <code>[3..4]</code> range. To be able to do it using the Rebol 2.100.111 interpreter the user needs to define:

<pre>
my-series: [#[none] #[none] d e]
</pre>

Now:

<pre>
pick my-series 3 ; == d
pick my-series 4 ; == e
</pre>

In <code>rebol/version == 2.7.8</code> the following works:

<pre>
index? my-series: #[block! [d e] -1] ; == -1
pick my-series 3 ; == d
pick my-series 4 ; == e
</pre>

Comparing the two alternatives we see that in Rebol 2.7.8 we did not have to insert the extraneous <code>#[none]</code> values to the block to achieve the same effect. Thus, the Rebol 2.7.8 approach is more flexible.

====Consistent handling of pre-head series====

This includes:

* Mention pre-head series in the documentation (a definition suffices).
* Stop calling pre-head series "illegal series" (this is the "easiest to implement" part of the proposal).
* Define the simple functions described above (quite easy as well).
* Amend the <code>mold</code> function to not trigger an error. For example, an expression like <code>mold #[block! [a] -2]</code> can yield <code>"[a]"</code>.
* Amend the <code>length?</code> function to work like the <code>length-of</code> function above.
* Define new <code>back-any</code> function going to the previous position even when it is a pre-head position.
* Define new <code>skip-any</code> function going to the specified position even if it is a pre-head position.

'''Advantages:'''

* consistence
* comfortable indexing (see below)
* flexibility
* usefulness

==Past-tail series==

'''Definition:''' ''Past-tail'' series are series having <code>displacement</code> greater than the payload size.

Unlike pre-head series, past-tail series cannot be suppressed (since series have time-independent displacement and "shrinkable" payload).

====Inconsistencies====

'''Example:''' In Rebol 2.7.8 interpreter the help string of the <code>tail?</code> function states:

<pre>
"Returns TRUE if a series is at its tail."
</pre>

However, the actual behaviour is:

<pre>
s: skip  [a b c d] 3
clear skip s -2
same? s tail s ; == false
tail? s ; == true
</pre>

, which, in my opinion, contradicts the help string. In the Rebol 2.100.111 interpreter the help string of the <code>tail?</code> function has been corrected, but the 'tail' and 'tail?' function names alone (when not reading their help strings) still look misleading. Also, we obtain:

<pre>
index? s ; == 2
</pre>

, while

<pre>
mold/all s ; == "#[block![a]4]"
</pre>

, which shows the correct result.

'''Example:'''

<pre>
mold/all load "#[block! [a] 4]" ; == "#[block![a]2]"
</pre>

* The inconsistency is that if it is "illegal" for the interpreter to create the <code>#[block! [a] 4]</code> block, why does the <code>load</code> function accept the string as "legal" and produce a result that is incompatible with the specification instead of triggering an error? This is strange knowing that the interpreter does (and cannot stop, in fact) produce the <code>#[block! [a] 4]</code> series as demonstrated above.
* In Rebol 2.7.8 interpreter the <code>index?</code> function pretends that the past-tail positions it encounters aren't past-tail. This just impairs the reflexivity of the language, because the user can obtain correct informations using other means as demonstrated.
* The <code>tail?</code> function yields <code>#[true]</code> for past-tail, which looks misleading even if the help string of the function is amended (some users may not read help strings).
* Past-tail series are treated as "Series that must not be mentioned in the documentation".
* When discussed (if discussed at all), past-tail series are called "Illegal series". That is inconsistent. If it is a bug for such a value to exist, a consistent interpreter shall not produce it.
* Simple functions and reflectors defined above designed for handling and detecting past-tail series are missing in the interpreter.
* The <code>mold</code> function is not able to handle past-tail series triggering an error (<code>mold/all</code> works without a quirk). This is a serious problem - the <code>mold</code> function is used to print error reports and must not trigger an error when printing an error report unless we want the interpreter to crash.
* The <code>pick</code> function acknowledges past-tail positions allowing picking at such positions without triggering an error.
* The <code>next</code>, <code>skip</code> and <code>at</code> functions refuse to go to past-tail positions, ignoring that such positions exist and are acknowledged by <code>pick</code>.

====Possible amendments====

Just the incorrect behaviour of the <code>index?</code> function has been corrected in Rebol 2.100.111 interpreter. Due to the fact that series payloads can be cleared, any series with positive displacement can become past-tail. The interpreter cannot detect which series become past-tail when a payload is cleared, because that would make the <code>remove</code> and <code>clear</code> operations slower and more complicated than acceptable. Thus, it is not possible to amend the interpreter to not produce past-tail series at all. Therefore, the only serious alternative is to handle past-tail series consistently, which includes:

* Mention past-tail series in the documentation (a definition suffices, in my opinion).
* Stop calling past-tail series "Illegal series" (this is the easiest part of the proposal).
* Define the simple functions described above (quite easy as well).
* Amend the <code>load</code> function to yield the specified result when handling the <code>#[block! [a] 4]</code> source string.
* Amend the <code>mold</code> function to not trigger an error when handling past-tail series.
* Amend the <code>length?</code> function to work like the <code>length-of</code> function above.
* Define new <code>next-any</code> function going to the next position even when it is a past-tail position.
* Define the <code>skip-any</code> function so that it goes to the specified position even if it is a past-tail position.

'''Advantages:'''

* consistence

* some users want to have past-tail series

* the availability of past-tail series makes the language more flexible

* perhaps surprisingly, the availability of past-tail series can make index arithmetic and the implementation simpler

===Indexing===

Before discussing indexing, let's take a "philosophical detour"

====Does 0 "exist"?====

Some opponents of using 0 as an index state: "0 does not even exist, it should not be allowed as an index, then"

Agreed, it is a matter of definition whether 0 is considered an integer or not. Moreover, no definition can be considered "wrong", exactly because it is a definition, not a proposition. Nevertheless, some definitions turn out to be more useful than others, and that is what we can observe here after a close inspection.

====Does Rebol have 1-based indexing?====

Unsurprisingly, the answer is "yes".

'''Example:'''

<pre>
block: [a b]
pick block 1 ; == a
pick block 2 ; == b
</pre>

====Is Rebol indexing 1-based?====

Perhaps surprisingly, the answer is "no".

'''Example:'''

<pre>
index? block: #[block! [a b] 0] ; == 0
pick block 2 ; == a
pick block 3 ; == b
</pre>

As we use indices from the <code>2 <= index < 4</code> range to pick the values of the <code>block</code>, we are actually using 2-based indexing.

====Does Rebol have 0-based indexing?====

Rebol 2.100.111 actually does.

'''Example:'''

<pre>
block: #[block! [a b] 2]
pick block 0 ; == a
pick block 1 ; == b
</pre>

, i.e., we are using indices in the <code>0 <= index < 2</code> range to pick the values of the block, which means that we are using 0-based indexing.

However, Rebol 2.7.8 does not have 0-based indexing:

<pre>
block: #[block! [a b] 2]
pick block -1 ; == a
pick block 1 ; == b
</pre>

, i.e., in this case, the "index space" consists of two ranges, in fact. The first is the range containing just -1 (, i.e., -1-based), while the second is the range containing just 1 (, i.e., 1-based). This also demonstrates that Rebol 2.7.8.3.1 does not have true -1-based, or negative-based indexing, because the <code>pick</code> function uses a discontinuous range made of two arithmetically incompatible (using different index arithmetic) segments.

I think that it is good to discuss why this happened to Rebol 2.7.8. The main reason seems to be the "1 pointing at the current position" indexing. This, when using the "common indexing principle" assigning the previous position the previous integer number induces the "0 pointing backwards" case. "0 pointing backwards" looks incomfortable/unusual as some users object. However, the approach using smell of garlic to take away the smell of onion (removing 0 from the set of possible index values) did not bring any good. Hurting the index arithmetic this way is not just incomfortable as the "0 pointing backwards" case was, it is inconsistent. (Even the Rebol designer felt victim to this catch, causing bugs in his code.)

====Indexing inconsistencies====

* In Rebol 2.7.8 the <code>index?</code> function is not injective (one to one) function, because it assigns the tail index to all past-tail positions. This contradicts the principle of indexing that a one to one correspondence between indices and positions shall be established. In Rebol 2.100.111 this bug has been corrected.
* The <code>at</code> function is not injective (one to one) because it assigns the same series position to two different indices 0 and 1. Note that this is, in fact, a different property than the previous one. A mathematical object having both properties would not even be representable as a function. This bug is detectable in both Rebol 2.7.8 and Rebol 2.100.111.
* In Rebol 2.7.8 the <code>pick</code> function subdivides its range to two arithmetically incompatible segments. This has been corrected in Rebol 2.100.111.
* In Rebol 2.100.111 the index 0 "points backwards" when the <code>pick</code> function is used. This is not an inconsistency, but it contradicts the expectations of users unaccustomed to 0 "pointing backwards" meaning that this property is inconvenient for such users.

====Index arithmetic primer====

'''Task:'''

Define a <code>head-index?</code> function obtaining a series <code>s</code> and an index value <code>i</code> yielding an index value <code>j</code> such that the <code>pick s i</code> expression will be equivalent to the <code>pick head s j</code> expression.

'''Solutions:'''

This is the solution working when the <code>index?</code> function and the <code>pick</code> function both use indexing method compatible with the <code>skip</code> function indexing method:

<pre>
head-index?: func [s [series!] i [integer!]] [i + index? s]
</pre>

This is the solution working when the <code>index?</code> function and the <code>pick</code> function use the indexing methods from R3:

<pre>
head-index?: func [s [series!] i [integer!]] [i - 1 + index? s]
</pre>

This is the solution working in the present state of R2:

<pre>
head-index?: func [s [series!] i [integer!]] [case [i < 0 [i - index? s] i > 0 [i - 1 + index? s] i = 0 [0]]]
</pre>

'''Summary:'''

* The "skip indexing" uses the simplest index arithmetic, allowing the solution to be the simplest one.
* The index arithmetic used in Rebol 2.100.111 is simple as well, but not as simple as the optimal indexing.
* The non-arithmetic indexing used in Rebol 2.7.8 does not support any simple solution and it provokes errors even when experienced users are writing code.
