==Introduction==

This article:

* defines a mathematical model of Rebol series
* discusses the current state of the interpreter
* proposes changes

==Mathematical model of Rebol series==

'''Definition:''' we say that a mathematical function <code>S</code> is a ''Rebol series'' if:

<pre>
S('datatype)
</pre>

is one of the series! datatypes (series! datatypes are: string!, binary!, block!, ...),

<pre>
S('displacement)
</pre>

is a 32-bit signed integer, i.e., an integer value such that -2147483648 <= displacement <= 2147483647, and

<pre>
S('payload)
</pre>

is a payload.

'''Note:''' in the model, the displacement is a 32-bit signed integer, since in current interpreter versions, skips, offsets, etc. are implemented using 32-bit signed integers.

'''Definition:''' we say that mathematical function <code>D</code> is a series ''payload'' if for every executionTime <code>t</code> the value

<pre>
D(t,'size)
</pre>

is a nonnegative 32-bit signed integer value, i.e., if

<pre>
0 <= D(t,'size) <= 2147483647
</pre>

and for every integer value <code>i</code> such that <code>0 <= i < D(t,'size)</code>,

<pre>
D(t,i)
</pre>

is a Rebol value.

'''Note:'''

* <code>D(t,'size) = 0</code> is allowed, in which case we say that the payload is empty.

* for the same reasons as above, it only makes sense to use 32-bit signed integers for payload size, but since negative sizes do not make sense, only nonnegative numbers are used.

'''Convention:''' from now on, unless otherwise stated, symbol <code>t</code> will denote the executionTime value of the time when the evaluation of the expression started.

==The <code>head</code> function==

The <code>head</code> function is a function accepting a Rebol series <code>S</code> and returning its head.

We define that a series <code>T</code> is a head of the series <code>S</code>, if it has a displacement 0 and the same datatype and payload as <code>S</code>, i.e., 

<pre>
T('displacement) = 0
T('datatype)     = S('datatype)
T('payload)      = S('payload)
</pre>

Tests suggest that this model of the <code>head</code> function is equivalent to the function implemented in, e.g., the <code>rebol/version == 2.7.8.3.1</code> interpreter.

==The <code>at-head?</code> function==

The <code>at-head?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the given series is its own head.

<pre>
at-head?(S) = #[true]
</pre>

, if <code>S('displacement) = 0</code>

<pre>
at-head?(S) = #[false]
</pre>

, if <code>S('displacement) <> 0</code>

Note that the <code>at-head?</code> function is time-independent.

Comparing the <code>at-head?</code> function to the <code>head?</code> function, we find out that for <code>rebol/version == 2.7.8.3.1</code>:

* the <code>head?</code> function is time-dependent

<pre>
a: [1 2]
b: skip a 2
head? b ; == false
clear a
same? b head b ; == false
head? b ; == true
insert a [1 2]
head? b ; == false
</pre>

* If we take the <code>head</code> function as the definition of the head, the <code>head?</code> function is incorrect. To be correct, it should work like the <code>at-head?</code> function.

==The <code>pre-head?</code> function==

The <code>pre-head?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the series is at a pre-head position.

<pre>
pre-head?(S) = #[true]
</pre>

, if <code>S('displacement)</code> is negative

<pre>
pre-head?(S) = #[false]
</pre>

, if <code>S('displacement)</code> is nonnegative

Note that the <code>pre-head?</code> function is time-independent.

==The <code>tail</code> function==

The <code>tail</code> function is a function accepting a Rebol series <code>S</code> and returning its tail <code>T</code>.

<code>T</code> is a Rebol series with the same datatype as <code>S</code>, a displacement equal to the current payload size and the same payload as <code>S</code>, i.e.,

<pre>
T('datatype)     = S('datatype)
T('displacement) = S('payload)(t,'size)
T('payload)      = S('payload)
</pre>

Tests suggest that this model is implemented in the <code>rebol/version == 2.7.8.3.1</code> interpreter as the <code>tail</code> function.

==The <code>at-tail?</code> function==

The <code>at-tail?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the series is at its tail.

<pre>
at-tail?(S) = #[true]
</pre>

, if <code>S('displacement) = S('payload)(t,'size)</code>

<pre>
at-tail?(S) = #[false]
</pre>

, if <code>S('displacement) <> S('payload)(t,'size)</code>

Comparing the <code>at-tail?</code> function to the <code>tail?</code> function, we find out that for <code>rebol/version == 2.7.8.3.1</code>:

* If we take the <code>tail</code> function as the definition of the tail, the <code>tail?</code> function is incorrect. To be correct, it should work like the <code>at-tail?</code> function:

<pre>
a: [1 2 3]
b: skip a 2
clear a
same? b tail b ; == false
tail? b ; == true
</pre>

==The <code>is-empty?</code> function==

The <code>is-empty?</code> function should take a series as an argument and yield a logic! type value determining whether the given series is empty.

<pre>
is-empty?(S) = #[true]
</pre>

, if <code>max(0,S('displacement)) < S('payload)(t,'size)</code>, and

<pre>
is-empty?(S) = #[false]
</pre>

, if <code>max(0,S('displacement)) >= S('payload)(t,'size)</code>

Comparing the <code>is-empty?</code> function and the <code>empty?</code> function in <code>rebol/version == 2.7.8.3.1</code> we find out that

<pre>
empty? #[block! [] -1] ; == false
</pre>

, while the <code>is-empty?</code> function would yield <code>true</code>.

==The <code>past-tail?</code> function==

The <code>past-tail?</code> function is a function accepting a Rebol series <code>S</code> and returning a logic value determining whether the series is at a past-tail position.

<pre>
past-tail?(S) = #[true]
</pre>

, if <code>S('displacement) > S('payload)(t,'size)</code>

<pre>
past-tail?(S) = #[false]
</pre>

, if <code>S('displacement) <= S('payload)(t,'size)</code>

==The <code>length-of</code> function==

The <code>length-of</code> function is a function accepting a Rebol series <code>S</code> and returning a nonnegative integer determining the length of the series. It can be defined as follows:

<pre>
length-of(S) = max(0,S('payload)(t,'size) - max(0,S('displacement)))
</pre>

The <code>length?</code> function in the <code>rebol/version == 2.7.8.3.1</code> interpreter does not work like that as this test demonstrates:

<pre>
length? #[block! [] -2] ; == 3
</pre>

, while the <code>length-of</code> function yields 0 in such case.

==32-bit signed integer arithmetic with wrapping==

In <code>rebol/version == 2.7.8.3.1</code>, integers are 32-bit signed values. These functions implement signed arithmetic with wrapping (without overflow):

<pre>
Rebol [
	Title: "add-wrap"
	File: %add-wrap.r
	Author: "Ladislav Mecir"
	Purpose: "Addition with wrapping"
]

use [max-int-32 min-int-32] [
	max-int-32: 2147483647
	min-int-32: -2147483648
	add-wrap: func [
		{Add two values with wrapping (no overflow) and return the result}
		a [integer!]
		b [integer!]
	] [
		either a >= 0 [
			either max-int-32 - a < b [
				; a + b > max-int-32, subtract 2 ** 32
				a + min-int-32 + b + min-int-32
			] [a + b]
		] [
			; a < 0
			either min-int-32 - a > b [
				; a + b < min-int-32, add 2 ** 32
				a - min-int-32 + b - min-int-32
			] [a + b]
		]
	]
]

Rebol [
	Title: "subtract-wrap"
	File: %subtract-wrap.r
	Author: "Ladislav Mecir"
	Purpose: "Subtraction with wrapping"
]

use [max-int-32 min-int-32] [
	max-int-32: 2147483647
	min-int-32: -2147483648
	subtract-wrap: func [
		{Subtract B from A with wrapping (no overflow) and return the result}
		a [integer!]
		b [integer!]
	] [
		either b > 0 [
			either min-int-32 + b > a [
				; a - b < min-int-32, add 2 ** 32
				a - min-int-32 - b - min-int-32
			] [a - b]
		] [
			; b <= 0
			either max-int-32 + b < a [
				; a - b > max-int-32, subtract 2 ** 32
				a + min-int-32 - b + min-int-32
			] [a - b]
		]
	]
]
</pre>

Note: These functions assume that signed integers are implemented as two's complement.

Advantages:

* both functions accept any pair of 32-bit signed integers and always yield a 32-bit signed integer as a result

* for every pair of 32-bit signed integers <code>a, b</code> holds that

<pre>
a = add-wrap b subtract-wrap a b
</pre>

==The <code>offset-of</code> function==

Sometimes it is useful to know the offset between two series. If the displacements of the series are signed 32-bit numbers, it is possible to calculate the offset as a signed 32-bit number too, using the formula:

<pre>
offset-of(S,T) = subtract-wrap(T('displacement),S('displacement))
</pre>

The main difference between the <code>offset-of</code> function and the standard <code>offset?</code> function is that there are series for which the <code>offset?</code> function does not work:

<pre>
>> offset? tail a a
** Math Error: Math or number overflow
** Where: offset?
** Near: subtract index? series2 index? series1
</pre>

==Pre-head series==

'''Definition:''' ''Pre-head series'' are series having a negative <code>displacement</code>.

Problems:

* When discussed (if discussed at all), pre-head series are called "illegal series". That is inconsistent with the fact that such series can be created in <code>rebol/version == 2.7.8.3.1</code>:

<pre>
index? #[block! [a] -2] ; == -2
</pre>

* Pre-head series are treated obscurely, as "Series that must not be mentioned in the documentation".

* Simple reflectors detecting pre-head series are missing in the interpreter.

* The <code>mold</code> function is not able to handle pre-head series triggering an error (while <code>mold/all</code> works without a quirk). This is a serious problem - the <code>mold</code> function is used to print error reports and must not trigger an error when printing an error report unless we want the interpreter to crash.

* The <code>pick</code> function uses the approach characterized by many as the most useful, and allows picking at pre-head positions without triggering an error.

* Inconsistently with <code>pick</code> and <code>load</code>, the <code>back</code>, <code>skip</code> and <code>at</code> functions refuse to go to pre-head positions.

Possible amendments:

There are two different methods trying to handle the pre-head series:

* Amend the interpreter to not produce pre-head series at all - this approach has been tried in <code>rebol/version == 2.100.111.3.1</code>.

* Handle pre-head series consistently.

====Pre-head handling used in <code>rebol/version == 2.100.111.3.1</code>====

* The <code>load</code> function accepts the code <code>#[block! [a] -3]</code> as "legal" and produces a result that is incompatible with the specification instead of triggering an error.

* Due to the fact that it is impossible to suppress past-tail positions, this approach is not usable for past-tail series, meaning that this approach cannot be consistent with the approach used to handle past-tail series.

* This approach is incompatible and inconsistent with the behaviour of the <code>pick</code> function. It would be possible to change the behaviour of the <code>pick</code> function, but there is a broad agreement between Rebol users that the current behaviour of the function when picking at pre-head positions is useful and convenient.

* some users want to use pre-head series:

'''Example:''' Let's assume that a user wants to use a series of values [d e] indexed by numbers in the [3..4] range. To be able to do it using the <code>rebol/version == 2.100.111.3.1</code> interpreter the user needs to define:

<pre>
my-series: [#[none] #[none] d e]
</pre>

Now:

<pre>
pick my-series 3 ; == d
pick my-series 4 ; == e
</pre>

In <code>rebol/version == 2.7.8.3.1</code> the following works:

<pre>
index? my-series: #[block! [d e] -1] ; == -1
pick my-series 3 ; == d
pick my-series 4 ; == e
</pre>

Comparing the two alternatives we see that in <code>rebol/version == 2.7.8.3.1</code> we did not have to insert the extraneous <code>#[none]</code> values to the block to achieve the same effect, i.e., the <code>rebol/version == 2.7.8.3.1</code> solution is more flexible.

====Consistent handling of pre-head series====

This includes:

* Mention pre-head series in the documentation (a definition suffices, in my opinion).
* Stop calling pre-head series "illegal series" (this is the "easiest to implement" part of the proposal).
* Define the simple functions described above (quite easy as well).
* Amend the <code>mold</code> function to not trigger an error. An expression like <code>mold #[block! [a] -2]</code> can yield "[a]".
* Amend the <code>length?</code> function to work like the <code>length-of</code> function above.
* Define new <code>back-any</code> function going to the previous position even when it is a pre-head position.
* Define new <code>skip-any</code> function going to the specified position even if it is a pre-head position.

'''Advantages:'''

* consistence
* comfortable indexing (see below)
* flexibility
* usefulness

==Past-tail series==

'''Definition:''' ''Past-tail'' series are series having <code>displacement</code> greater than the payload size.

==Should past-tail series be allowed?==

The reasons why past-tail series should be allowed are:

* Unlike pre-head series, past-tail series cannot be suppressed (since series have time-independent displacement and "shrinkable" payload). Therefore, the <code>rebol/version == 2.7.8.3.1</code> interpreter constructs past-tail series:

<pre>
a: tail [1]
clear head a
mold/all a ; == "#[block! [] 2]"
</pre>

* some users want to have past-tail series

* the availability of past-tail series makes the language more flexible

* perhaps surprisingly, the availability of past-tail series can make index arithmetic and the implementation simpler

====Inconsistencies====

'''Example:''' In <code>rebol/version == 2.7.8.3.1</code> interpreter the help string of the <code>tail?</code> function states:

<pre>
"Returns TRUE if a series is at its tail."
</pre>

However, the actual behaviour is:

<pre>
s: skip  [a b c d] 3
clear skip s -2
same? s tail s ; == false
tail? s ; == true
</pre>

, which, in my opinion, contradicts the help string. In the <code>rebol/version == 2.100.111.3.1</code> interpreter the help string of the <code>tail?</code> function has been corrected, but the 'tail' and 'tail?' function names alone (when not reading their help strings) still look misleading. Also, we obtain:

<pre>
index? s ; == 2
</pre>

, while

<pre>
mold/all s ; == "#[block![a]4]"
</pre>

, which shows the correct result.

'''Example:'''

<pre>
mold/all load "#[block! [a] 4]" ; == "#[block![a]2]"
</pre>

* The inconsistency is that if it is "illegal" for the interpreter to create the <code>#[block! [a] 4]</code> block, why does the <code>load</code> function accept the string as "legal" and produce a result that is incompatible with the specification instead of triggering an error? This is strange knowing that the interpreter does (and cannot stop, in fact) produce the <code>#[block! [a] 4]</code> series as demonstrated above.
* In <code>rebol/version == 2.7.8.3.1</code> interpreter the <code>index?</code> function pretends that the past-tail positions it encounters aren't past-tail. This just impairs the reflexivity of the language, because the user can obtain correct informations using other means as demonstrated.
* The <code>tail?</code> function yields <code>#[true]</code> for past-tail, which looks misleading even if the help string of the function is amended (some users may not read help strings).
* Past-tail series are treated as "Series that must not be mentioned in the documentation".
* When discussed (if discussed at all), past-tail series are called "Illegal series". That is inconsistent. If it is a bug for such a value to exist, a consistent interpreter shall not produce it.
* Simple functions and reflectors defined above designed for handling and detecting past-tail series are missing in the interpreter.
* The <code>mold</code> function is not able to handle past-tail series triggering an error (<code>mold/all</code> works without a quirk). This is a serious problem - the <code>mold</code> function is used to print error reports and must not trigger an error when printing an error report unless we want the interpreter to crash.
* The <code>pick</code> function acknowledges past-tail positions allowing picking at such positions without triggering an error.
* The <code>mext</code>, <code>skip</code> and <code>at</code> functions refuse to go to past-tail positions, ignoring that such positions exist and are acknowledged by <code>pick</code>.

====Possible amendments====

Just the incorrect behaviour of the <code>index?</code> function has been corrected in <code>rebol/version == 2.100.111.3.1</code> interpreter. Due to the fact that series payloads can be cleared, any series with positive displacement can become past-tail. The interpreter cannot detect which series become past-tail when a payload is cleared, because that would make the <code>remove</code> and <code>clear</code> operations slower and more complicated than acceptable. Thus, it is not possible to amend the interpreter to not produce past-tail series at all. Therefore, the only serious alternative is to handle past-tail series consistently, which includes:

* Mention past-tail series in the documentation (a definition suffices, in my opinion).
* Stop calling past-tail series "Illegal series" (this is the easiest part of the proposal).
* Define the simple functions described above (quite easy as well).
* Amend the <code>load</code> function to yield the specified result when handling the "#[block! [a] 4]" source string.
* Amend the <code>mold</code> function to not trigger an error when handling past-tail series.
* Amend the <code>length?</code> function to work like the <code>length-of</code> function above.
* Define new <code>next-any</code> function going to the next position even when it is a past-tail position.
* Define the <code>skip-any</code> function so that it goes to the specified position even if it is a past-tail position.

'''Advantages:'''

* consistence
* comfortable indexing (see below)

===Indexing===

Before discussing indexing, let's take a "philosophical detour"

====Does 0 "exist"?====

Some opponents of using 0 as an index state: "0 does not even exist, it should not be allowed as an index, then"

Agreed, it is a matter of definition whether 0 is considered an integer or not. Moreover, no definition can be considered "wrong", exactly because it is a definition, not a proposition. Nevertheless, some definitions turn out to be more useful than others, and that is what we can observe here after a close inspection.

====Does Rebol have 1-based indexing?====

Unsurprisingly, the answer is "yes".

'''Example:'''

<pre>
block: [a b]
pick block 1 ; == a
pick block 2 ; == b
</pre>

====Is Rebol indexing 1-based?====

Perhaps surprisingly, the answer is "no".

'''Example:'''

<pre>
index? block: #[block! [a b] 0] ; == 0
pick block 2 ; == a
pick block 3 ; == b
</pre>

As we use indices from the <code>2 <= index < 4</code> range to pick the values of the <code>block</code>, we are actually using 2-based indexing.

====Does Rebol have 0-based indexing?====

<code>rebol/version == 2.100.111.3.1</code> actually does.

'''Example:'''

<pre>
block: #[block! [a b] 2]
pick block 0 ; == a
pick block 1 ; == b
</pre>

, i.e., we are using indices in the <code>0 <= index < 2</code> range to pick the values of the block, which means that we are using 0-based indexing.

However, <code>rebol/version == 2.7.8.3.1</code> does not have 0-based indexing:

<pre>
block: #[block! [a b] 2]
pick block -1 ; == a
pick block 1 ; == b
</pre>

, i.e., in this case, the "index space" consists of two ranges, in fact. The first is the range containing just -1 (, i.e., -1-based), while the second is the range containing just 1 (, i.e., 1-based). This also demonstrates that <code>rebol/version == 2.7.8.3.1</code> does not have true -1-based, or negative-based indexing, because the <code>pick</code> function uses a discontinuous range made of two arithmetically incompatible (using different index arithmetic) segments.

I think that it is good to discuss why this happened to <code>rebol/version == 2.7.8.3.1</code>. The main reason seems to be the "1 pointing at the current position" indexing. This, when using the "common indexing principle" assigning the previous position the previous integer number induces the "0 pointing backwards" case. "0 pointing backwards" looks incomfortable/unusual as some users object. However, the approach using smell of garlic to take away the smell of onion (removing 0 from the set of possible index values) did not bring any good. Hurting the index arithmetic this way is not just incomfortable as the "0 pointing backwards" case was, it is inconsistent. (Even the Rebol designer felt victim to this catch, causing bugs in his code.)

====Indexing inconsistencies====

* In <code>rebol/version == 2.7.8.3.1</code> the <code>index?</code> function is not injective (one to one) function, because it assigns the tail index to all past-tail positions. This contradicts the principle of indexing that a one to one correspondence between indices and positions shall be established. In <code>rebol/version == 2.100.111.3.1</code> this bug has been corrected.
* The <code>at</code> function is not injective (one to one) because it assigns the same series position to two different indices 0 and 1. Note that this is, in fact, a different property than the previous one. A mathematical object having both properties would not even be representable as a function. This bug is detectable in both <code>rebol/version == 2.7.8.3.1</code> and <code>rebol/version == 2.100.111.3.1</code>.
* In <code>rebol/version == 2.7.8.3.1</code> the <code>pick</code> function subdivides its range to two arithmetically incompatible segments. This has been corrected in <code>rebol/version == 2.100.111.3.1</code>.
* In <code>rebol/version == 2.100.111.3.1</code> the index 0 "points backwards" when the <code>pick</code> function is used. This is not an inconsistency, but it contradicts the expectations of users unaccustomed to 0 "pointing backwards" meaning that this property is inconvenient for such users.

====Index arithmetic primer====

'''Task:'''

Define a <code>head-index?</code> function obtaining a series <code>s</code> and an index value <code>i</code> yielding an index value <code>j</code> such that the <code>pick s i</code> expression will be equivalent to the <code>pick head s j</code> expression.

'''Solutions:'''

This is the solution working when the <code>index?</code> function and the <code>pick</code> function both use indexing method compatible with the <code>skip</code> function indexing method:

<pre>
head-index?: func [s [series!] i [integer!]] [i + index? s]
</pre>

This is the solution working when the <code>index?</code> function and the <code>pick</code> function use the indexing methods from R3:

<pre>
head-index?: func [s [series!] i [integer!]] [i - 1 + index? s]
</pre>

This is the solution working in the present state of R2:

<pre>
head-index?: func [s [series!] i [integer!]] [case [i < 0 [i - index? s] i > 0 [i - 1 + index? s] i = 0 [0]]]
</pre>

'''Summary:'''

* The "skip indexing" uses the simplest index arithmetic, allowing the solution to be the simplest one.
* The index arithmetic used in <code>rebol/version == 2.100.111.3.1</code> is simple as well, but not as simple as the optimal indexing.
* The non-arithmetic indexing used in <code>rebol/version == 2.7.8.3.1</code> does not support any simple solution and it provokes errors even when experienced users are writing code.

==Proposed functions==

===The <code>curr</code> function===

The <code>curr</code> function is a function accepting a Rebol series <code>S</code> and returning the Rebol value at its current position.

<pre>
(curr S) = (do payload S t displacement S)
</pre>

, if <code>in-bounds? S</code>

<pre>
(curr S) = #[none]
</pre>

otherwise.
